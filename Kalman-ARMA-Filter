# -*- coding: utf-8 -*-
"""KalamanPractice1-withTeacher

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LJ4t7JIIjRfN3S6TJKSB7Wozp1F2o5PD
"""

import math as math
import cmath as cmath
import numpy as np
from scipy import signal
!pip install arma_ToStateSpace
from arma_ToStateSpace import arma_ToStateSpace


def arma_KalmanLE(A, C, v, y):

    A=np.transpose(A)
    C=np.transpose(C)

    if (np.size(y,0) == 1):
        y = y.T

    N = np.size(y,0) 

# generate the state space representation
    (F, R, H, Q) = arma_ToStateSpace(A, C, v)

# The initial state with zeros
    m = np.size(F,0)

# Initialise the state and covariance X and P0
    X = np.zeros([m, 1])
    P = np.zeros([m, m])
    S = np.eye(m**2) - np.kron(F,F)       
    Qf = Q.flatten()
    Pf = np.matmul(np.linalg.inv(S), Qf[np.newaxis, :].T)
    P = Pf.reshape(m, m)

# if NaN, just return very large likelihood
    if (np.isnan(np.linalg.det(P))):
        L = np.inf
        v_est = np.zeros([1,N])
        v_var = np.ones([1,N])
        yp = np.zeros([1,N])
        return(L, v_est, v_var, yp)

# Evaluate the likelihood across series
    L = complex(0, 0)
    yp = np.zeros([N,1])
    v_est = np.zeros([N,1])
    v_var = np.zeros([N,1])

    for i in range(0, N):

        # Prediction step
        X_pred = np.matmul(F, X)
        y_pred = np.matmul(H, X_pred)
        P_pred = np.matmul(np.matmul(F, P), F.T) + Q

        # Costing step
        v_est[i] = y[i] - y_pred
        v_var[i] = np.matmul(np.matmul(H, P_pred), H.T)
        yp[i] = y_pred
        L = L + (1/2) * cmath.log(v_var[i]) + (1/2/v_var[i]) * v_est[i]**2
        
        # Update step
        K = np.matmul(P_pred, H.T) / v_var[i]
        X = X_pred + K * v_est[i]
        P = P_pred - np.matmul(np.matmul(K, H), P_pred)

# Add in the normalisation constant 
    L = L + (N/2) * cmath.log(2*math.pi)

    return(L, v_est, v_var, yp)

